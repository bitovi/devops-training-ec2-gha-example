on:
  push:
    branches: [ d2ec2 ]

permissions:
  contents: read
 
env:
  STACK_DESTROY: 
  AWS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID_SANDBOX }}
  AWS_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY_SANDBOX }}
  AWS_REGION: us-east-1
  #AWS_AZ: #us-east-1c
  ENVIRONMENT: test
jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - id: efs
        uses: bitovi/github-actions-deploy-efs-volume@main
        with:
          aws_access_key_id: ${{ env.AWS_KEY_ID }}
          aws_secret_access_key: ${{ env.AWS_ACCESS_KEY }}
          aws_default_region: ${{ env.AWS_REGION }}
          tf_state_file_name_append: ${{ github.action }}${{ env.ENVIRONMENT }}
          aws_efs_create_mount_target: true
          aws_efs_create_ha: true
         # aws_vpc_availability_zones: ${{ env.AWS_AZ }}
          tf_stack_destroy: ${{ env.STACK_DESTROY }}

      - id: rds
        uses: bitovi/github-actions-deploy-rds@commons-bump
        with:
          aws_access_key_id: ${{ env.AWS_KEY_ID }}
          aws_secret_access_key: ${{ env.AWS_ACCESS_KEY }}
          aws_default_region: ${{ env.AWS_REGION }}
          tf_state_file_name_append: ${{ github.action }}${{ env.ENVIRONMENT }}
        #  aws_vpc_availability_zones: ${{ env.AWS_AZ }}
          aws_vpc_id: ${{ steps.efs.outputs.aws_vpc_id }}
          tf_stack_destroy: ${{ env.STACK_DESTROY }}

      - id: ec2
        uses: bitovi/github-actions-deploy-docker-to-ec2@commons-testing
        with:
          aws_access_key_id: ${{ env.AWS_KEY_ID }}
          aws_secret_access_key: ${{ env.AWS_ACCESS_KEY }}
          aws_default_region: ${{ env.AWS_REGION }}
          aws_elb_app_port: 3000
          aws_ec2_instance_type: t3.small
       #   aws_elb_create: false
          tf_state_bucket_destroy: true
          tf_state_file_name_append: ${{ github.action }}${{ env.ENVIRONMENT }}
          aws_efs_fs_id: ${{ steps.efs.outputs.aws_efs_fs_id }}
          aws_efs_create_mount_target: false
          env_aws_secret: ${{ steps.rds.outputs.db_secret_details_name }}
          #aws_vpc_availability_zones: ${{ env.AWS_AZ }}
          aws_vpc_id: ${{ steps.efs.outputs.aws_vpc_id }}
          tf_stack_destroy: ${{ env.STACK_DESTROY }}
          tf_state_bucket: tf-state-leo
          ansible_skip: true
          
          
          # We can use this to set the location of the files based on the path
          # docker_repo_app_directory: ${{ env.ENVIRONMENT }}
